import cv2

'Canny算子'
'''
边缘：一个像素，不一定封闭，是提取轮廓的前提
梯度：不一定是一个像素，有可能是多个像素
轮廓：对于边缘的扩充，是封闭的，属于边缘的子集

Canny边缘检查算法的步骤：
    1. 彩色图转换为灰度图
    2. 应用高斯滤波来平滑图像——>去除噪声的影响
        由于边缘检测容易受到图像中噪声的影响
    3. 找寻图像的强度梯度
        Canny的基本思想是寻找一副图像中强度变化最强的位置。所谓的变化最强，指的是梯度方向。
        平滑后的图像中的每个像素点的土豆可以由Sobel算子来获得：
        1)首先，利用Sobel算子得到沿x轴和y轴方向的梯度G_x和G_y
        2)由G_x和G_y便可以计算每一个像素点的梯度幅值G
        3)接着，每一个像素点用G代替，难以标定边界的真正位置，G值越大，对应的颜色为白色
        4)然后，这些技术通常非常粗，难以标定边界的真正位置，还必须存储梯度方向theta
    4. 应用非极大值一直技术来消除边误检(本来不是边缘但是检测出来是)
        沿着梯度theta方向比较像像素点，若该像素点与两侧相比最大则保留，否则抑制(置为0)
        这一步的目的是将模糊边界变得清晰，剔除一大部分
        不是边缘的点。
    5. 双阈值边缘连接处理
        规则：设定两个阈值，minVal，maxVal
            大于maxVal的边缘肯定是边缘(保留),低于minVal的边缘是非边缘(舍去)
            对于介于两者之间的值，判断是否与真正的边界(强边界)相连接,相连就保留，否则丢弃
    6. 二值化图像输出结果
'''
# 1. 转化为灰度图
img = cv2.imread("../images/18.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. 高斯模糊
gaussian = cv2.GaussianBlur(gray, ksize=(3, 3), sigmaX=3)

# 3. 边缘提取
canny = cv2.Canny(image=img, threshold1=50, threshold2=150)

cv2.imshow("canny", canny)
cv2.waitKey(0)
cv2.destroyAllWindows()

